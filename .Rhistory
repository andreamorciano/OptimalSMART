fun = fun(x1 = p1, x2 = p2, x3 =p3, N = N.opt(x1 = p1, x2 = p2, x3 = p3)),
Cost = Cost(N = N.opt(x1 = p1, x2 = p2, x3 = p3), x1 = p1, x2 = p2, x3 = p3)) %>% arrange(fun)
lod_val <- lod  %>% slice(which.min(fun)) %>% select(fun)
lod_val <- as.numeric(lod_val)
lod <- lod %>% rowwise() %>% mutate(RE = lod_val / fun)
temp <- rbind(temp, lod)
}
values_mmd <- temp %>% filter(!is.na(gamma1))
#Temporary dataframe used to save the results obtained in the following for loop
temp2 <- as.data.frame(matrix(NA,ncol = 9))
colnames(temp2) <- c(colnames(values_mmd[1:8]),"minRE")
#For each design in the design space, the minimum relative efficiency is computed, which is the lowest
#efficiency that the design achieves all over the parameter space. Then the design having the highest minimum RE
#is chosen as the MMD.
for (k in 1:nrow(des_space)) {
p11 <- des_space[k,1]
p21 <- des_space[k,2]
p31 <- des_space[k,3]
mmd <- values_mmd %>% filter(p1 == p11 & p2 == p21 & p3 == p31) %>% slice(which.min(RE))
mmd <- mmd %>% mutate(minRE = round(RE,5)) %>% select(-RE)
temp2 <- rbind(temp2,mmd)
}
g1_ex <- paste0("[",paste(min(gamma1),max(gamma1), sep = ", "),"]")
g2_ex <- paste0("[",paste(min(gamma2),max(gamma2), sep = ", "),"]")
#MMD is saved in a separate object.
mmd <- temp2 %>% filter(!is.na(gamma1)) %>% arrange(desc(minRE))
mmd <- mmd %>% dplyr::transmute(p1_mmd = p1, p2_mmd = p2, p3_mmd = p3, N_mmd = N, fun = fun, Cost = round(Cost), minRE = minRE)
mmd_value <- mmd %>% slice(which.max(minRE)) %>% dplyr::transmute(gamma1 = g1_ex, gamma2 = g2_ex, p1_mmd = p1_mmd,
p2_mmd = p2_mmd, p3_mmd = p3_mmd, N_mmd = round(N_mmd, 4), fun = fun, Cost = Cost, MMV = minRE)
#Relative efficiency and cost efficiency of the balanced design
r.eff <- mmd %>% filter(p1_mmd == 0.50 & p2_mmd == 0.50 & p3_mmd == 0.50) %>% select(minRE)
cost.eff <- mmd_value$Cost * (1/r.eff)
time_fin = Sys.time() - time_in
mmd_value <- mmd_value %>% dplyr::transmute(gamma1 = gamma1, gamma2 = gamma2, Cp = Cp, Cn = Cn, Cpn = Cpn, p1_mmd = p1_mmd,
p2_mmd = p2_mmd, p3_mmd = p3_mmd, N_mmd = N_mmd, fun = fun, Cost = Cost, MMV = MMV,
w13 = w13, w14 = w14, w23 = w23, w24 = w24)
colnames(mmd_value) <- c(paste0(intToUtf8(947),c(1:2)," Range"), "Cp", "Cn", "Cpn", "p1.mmd", "p2.mmd", "p3.mmd",
"N.mmd", paste(intToUtf8(966), "value"), "Cost", "MMV",
paste0(intToUtf8(955),c("13","14","23","24")))
#Contour plots for p1, p2 and p3 when fixing one at the time to its value in the MMD design.
mmd_value2 <- mmd_value %>% mutate(minRE = MMV) %>% select(-MMV)
#Contour plot for p2 and p3. p1 fixed
cont_data1 <- mmd %>% filter(p1_mmd == mmd_value$p1.mmd)
cont_plot1 <- cont_data1 %>% ggplot(aes(x = p2_mmd, y = p3_mmd, z = minRE))+ stat_contour(breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95),
colour = "black") +
geom_point(data = mmd_value2, aes(x = p2.mmd, y = p3.mmd)) +
theme_minimal() + theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank() ,axis.line.x = element_line(colour = "black"),
axis.line.y = element_line(colour = "black"), legend.position = "none", axis.text = element_text(size = 12)) +
labs(x = expression(p[2]), y = expression(p[3])) + coord_cartesian(xlim = c(0, 1), ylim = c(0,1)) +
scale_x_continuous(breaks = seq(0,1,0.1)) +
scale_y_continuous(breaks = seq(0,1,0.1))
#Contour plot for p1 and p3. p2 fixed
cont_data2 <- mmd %>% filter(p2_mmd == mmd_value$p2.mmd)
cont_plot2 <- cont_data2 %>% ggplot(aes(x = p1_mmd, y = p3_mmd, z = minRE)) + stat_contour(breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95),
colour = "black") +
geom_point(data = mmd_value2, aes(x = p1.mmd, y = p3.mmd)) +
theme_minimal() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.line.x = element_line(colour = "black"),
axis.line.y = element_line(colour = "black"), legend.position = "none", axis.text = element_text(size = 12)) +
labs(x = expression(p[1]), y = expression(p[3])) + coord_cartesian(xlim = c(0, 1), ylim = c(0,1)) +
scale_x_continuous(breaks = seq(0,1,0.1)) +
scale_y_continuous(breaks = seq(0,1,0.1))
#Contour plot for p1 and p2. p3 fixed
cont_data3 <- mmd %>% filter(p3_mmd == mmd_value$p3.mmd)
cont_plot3 <- cont_data3 %>% ggplot(aes(x = p1_mmd, y = p2_mmd, z = minRE)) + stat_contour(breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95),
colour = "black") +
geom_point(data = mmd_value2, aes(x = p1.mmd, y = p2.mmd)) +
theme_minimal() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.line.x = element_line(colour = "black"),
axis.line.y = element_line(colour = "black"), legend.position = "none", axis.text = element_text(size = 12))+
labs(x = expression(p[1]), y = expression(p[2])) + coord_cartesian(xlim = c(0, 1), ylim = c(0,1)) +
scale_x_continuous(breaks = seq(0,1,0.1)) +
scale_y_continuous(breaks = seq(0,1,0.1))
list(values_mmd = values_mmd, mmd_value = mmd_value, mmd = mmd, time = time_fin, r.eff = r.eff,
cost.eff = cost.eff, cont_plot1 = cont_plot1, cont_plot2 = cont_plot2, cont_plot3 = cont_plot3)
}
maximin_design(gamma1 = 0.25, gamma2 = 0.40, Cp = 50, Cn = 300, w13= 0.7, w14 = 0.1, w23 = 0.1, w24=0.1,
stepsize = 0.05)
maxim_des <- maximin_design(gamma1 = 0.25, gamma2 = 0.40, Cp = 50, Cn = 300, w13= 0.7, w14 = 0.1, w23 = 0.1, w24=0.1,
stepsize = 0.05)
maxim_des
rm(list=ls())
g1.vec<-g2.vec<-seq(0.0001,0.9999,l=stepsize)
gamma1 = 0.5
gamma2 = 0.5
Ca = 10
Cb = 10
Cc = 10
Cd = 10
Ce = 10
Cf = 10
Cg = 10
Ch = 10
w13 = 0.7
w23 = 0.1
w14 = 0.1
w24 = 0.1
C = 100000
stepsize = 101
g1.vec<-g2.vec<-seq(0.0001,0.9999,l=stepsize)
gamma.frame <- data.frame(expand.grid(gamma1 = g1.vec, gamma2 = g2.vec), p1.opt = NA, p2.opt = NA, p3.opt = NA,
N = NA, fun = NA)
View(gamma.frame)
time_in <- Sys.time()
#Function to compute sample size, given p1, p2, p3 and the constants.
N.opt <- function(x1, x2, x3){
N <- C / (x1*(Ca+Cc*g1+(1-g1)*x2*Cd+(1-g1)*(1-x2)*Ce) + (1-x1)*(Cb+Cf*g2+(1-g2)*x3*Cg+(1-g2)*(1-x3)*Ch))
N <- round(N, digits = 9)
}
##Function that computes total cost
Cost <- function(N, x1, x2, x3){
C <- N*(x1*(Ca+Cc*g1+(1-g1)*x2*Cd+(1-g1)*(1-x2)*Ce) + (1-x1)*(Cb+Cf*g2+(1-g2)*x3*Cg+(1-g2)*(1-x3)*Ch))
}
#Function value, given p1, p2, p3, N and the constants.
fun <- function(x1, x2, x3, N){
((g1*x2+(1-g1))/(N*x1*x2) + (g2*x3+(1-g2))/(N*(1-x1)*x3))*w13 +
((g1*x2+(1-g1))/(N*x1*x2) + (g2*(1-x3)+(1-g2))/(N*(1-x1)*(1-x3)))*w14 +
((g1*(1-x2)+(1-g1))/(N*x1*(1-x2)) + (g2*x3+(1-g2))/(N*(1-x1)*x3))*w23 +
((g1*(1-x2)+(1-g1))/(N*x1*(1-x2)) + (g2*(1-x3)+(1-g2))/(N*(1-x1)*(1-x3)))*w24
}
#The temporary minimum of the function for the evaluated combinations of p1, p2 and p3 is computed
iterative <- function(p1, p2, p3){
#A dataframe with possible combinations of p1, p2 and p3 is created and the function value, the sample size
#and the cost are computed. Then the combination that provides the minimum value is chosen as the local temporary minimum.
values <- data.frame(expand.grid(p1 = p1, p2 = p2, p3 = p3), N = NA, fun = NA, Cost = NA)
values <- values %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N),Cost = Cost(N, p1, p2, p3))
intermed <- values %>% arrange(fun) %>% filter(fun > 0 & p1>0 & p1<1 & p2<1 & p2>0 & p3<1 & p3>0) %>% slice(which.min(fun))
return(intermed)
}
rm(list=ls())
g1.vec <- g2.vec <-  seq(0,1,101)
g1.vec <- g2.vec <-  seq(0,1,101)
g1.vec <- g2.vec <-  seq(0,1,l=101)
rm(list=ls())
gamma1 = 0.25
gamma2 = 0.40
Cp = 50
Cn = 300
Cpn = Cp +Cn
w13 = 0.7
w23 = 0.1
w14 = 0.1
w24 = 0.1
C = 100000
stepsize = 101
install.packages('htmlwidgets')
install.packages("htmlwidgets")
source("Numerical derivation optimal proportions.R")
setwd("~/Desktop/Article Optimal proportions/Shiny article/Shiny Nut Phy")
source("Numerical derivation optimal proportions.R")
rm(list=ls())
source("Numerical derivation optimal proportions.R")
g1.true <- 0.25
g2.true <- 0.40
analytic.prop <- function(gamma1 = 0.5, gamma2 = 0.5, Cp = 50, Cn = 300, w13 = 0.25, w23 = 0.25, w14 = 0.25, w24 = 0.25, C = 100000){
time_in <- Sys.time()
g1 <- gamma1
g2 <- gamma2
#function stops if the sum of weights is different from 1
wgts <- w13 + w14 + w23 + w24
stopifnot(near(wgts, 1))
#Second-stage treatment cost
Cpn <- Cn + Cp
#Function to compute sample size, given p1, p2, p3 and the constants.
N.opt <- function(x1, x2, x3){
N <- C / (x1*(Cp+Cp*g1+(1-g1)*x2*Cn+(1-g1)*(1-x2)*Cpn) + (1-x1)*(Cn+Cn*g2+(1-g2)*x3*Cp+(1-g2)*(1-x3)*Cpn))
N <- round(N, digits = 9)
}
##Function that computes total cost
Cost <- function(N, x1, x2, x3){
C <- N*(x1*(Cp+Cp*g1+(1-g1)*x2*Cn+(1-g1)*(1-x2)*Cpn) + (1-x1)*(Cn+Cn*g2+(1-g2)*x3*Cp+(1-g2)*(1-x3)*Cpn))
}
#Function value, given p1, p2, p3, N and the constants.
fun <- function(x1, x2, x3, N){
((g1*x2+(1-g1))/(N*x1*x2) + (g2*x3+(1-g2))/(N*(1-x1)*x3))*w13 +
((g1*x2+(1-g1))/(N*x1*x2) + (g2*(1-x3)+(1-g2))/(N*(1-x1)*(1-x3)))*w14 +
((g1*(1-x2)+(1-g1))/(N*x1*(1-x2)) + (g2*x3+(1-g2))/(N*(1-x1)*x3))*w23 +
((g1*(1-x2)+(1-g1))/(N*x1*(1-x2)) + (g2*(1-x3)+(1-g2))/(N*(1-x1)*(1-x3)))*w24
}
#The temporary minimum of the function for the evaluated combinations of p1, p2 and p3 is computed
iterative <- function(p1, p2, p3){
#A dataframe with possible combinations of p1, p2 and p3 is created and the function value, the sample size
#and the cost are computed. Then the combination that provides the minimum value is chosen as the local temporary minimum.
values <- data.frame(expand.grid(p1 = p1, p2 = p2, p3 = p3), N = NA, fun = NA, Cost = NA)
values <- values %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N),Cost = Cost(N, p1, p2, p3))
intermed <- values %>% arrange(fun) %>% filter(Cost < C-0.000000001 & fun > 0 & p1>0 & p1<1 & p2<1 & p2>0 & p3<1 & p3>0) %>% slice(which.min(fun))
return(intermed)
}
#p1, p2 and p3 are initialized
p1 <- p2 <- p3 <- seq(0.01, 0.99, by = 0.02)
#First iteration is computed
iterations <- data.frame(1, iterative(p1,p2,p3))
colnames(iterations) <- c("Iteration #", "p1", "p2", "p3", "N", "fun", "Cost")
i <- 2
#The step size and the size of the interval change according to the iteration number. For iteration #2 the algorithm
#is distint than for the other iterations.
while (i < 100) {
intermed <- iterations[i-1, -1]
if(i != 2){
k <- 3.5 * 10^(-(i-1))
p1 <- seq((intermed$p1 - k), (intermed$p1 + k), by = 2 * 10^(-i))
p2 <- seq((intermed$p2 - k), (intermed$p2 + k), by = 2 * 10^(-i))
p3 <- seq((intermed$p3 - k), (intermed$p3 + k), by = 2 * 10^(-i))
} else {
k <- 1.8 * 10^(-(i-1))
p1 <- seq((intermed$p1 - k), (intermed$p1 + k), by = 0.3* 10^(-i+1))
p2 <- seq((intermed$p2 - k), (intermed$p2 + k), by = 0.3 * 10^(-i+1))
p3 <- seq((intermed$p3 - k), (intermed$p3 + k), by = 0.3 * 10^(-i+1))
}
temp <- data.frame(i, iterative(p1,p2,p3))
colnames(temp) <- c("Iteration #", "p1", "p2", "p3", "N", "fun", "Cost")
iterations <- rbind(iterations, temp)
#Convergence criteria that is met if the results found in two subsequent iterations are the same up to a certain
#degree of precision
i <- ifelse(near(iterations[i-1,2], iterations[i,2], tol = .Machine$double.eps^0.3)
& near(iterations[i-1,3], iterations[i,3], tol = .Machine$double.eps^0.3) &
near(iterations[i-1,4], iterations[i,4], tol = .Machine$double.eps^0.3) & i > 5, 100, i + 1)
}
#Optimal design is found after the convergence criterion is met
final <- iterations %>% transmute(gamma1 = g1, gamma2 = g2, Cp = Cp, Cn = Cn, Cpn = Cpn,
p1.opt = round(p1, 4), p2.opt = round(p2, 4), p3.opt = round(p3, 4),
N.opt = round(N,4), fun = round(fun, 8), Cost = round(Cost),
w13 = w13, w14 = w14, w23 = w23, w24 = w24) %>% slice(which.max(iterations$`Iteration #`))
#Relative efficiency is computed as the ratio of the function value of the balanced design and that of the optimal
#design found above. Cost efficiency is then computed
#Balanced design
N_bal <- N.opt(x1 = 0.5, x2 = 0.5, x3 = 0.5)
fun_bal <- fun(x1 = 0.5, x2 = 0.5, x3 = 0.5, N = N_bal)
#Relative efficiency and cost efficiency
r.eff <- final$fun / fun_bal
cost.eff <- final$Cost * (1/r.eff)
#Plot relative efficiency
#A dataframe with possible combinations of p1, p2 and p3 is created and relative efficiency with respect to the
#optimal design is computed
re_data <- data.frame(expand.grid(p1 = seq(0.01, 0.99, 0.03), p2 = seq(0.01, 0.99, 0.03),
p3 = seq(0.01, 0.99, 0.03)), N = NA, fun = NA, r.eff = NA, eff_cost = NA)
ff <- final %>% mutate(r.eff = 1) %>% select(p1.opt, p2.opt, p3.opt, N.opt, fun, r.eff, Cost)
colnames(ff) <- colnames(re_data)
re_data <- re_data %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N), r.eff = round((ff$fun / fun),4), eff_cost = round(C * (1/r.eff),4)) %>%
arrange(fun)
#Column names for the object containing the optimal design are set
colnames(final) <- c(paste0(intToUtf8(947),c(1:2)), "Cp", "Cn", "Cpn", "p1.opt", "p2.opt", "p3.opt", "N.opt",
paste(intToUtf8(966), "value"), "Cost", paste0(intToUtf8(955),c("13","14","23","24")))
#Contour plots
#p1 fixed to its optimal value. Contour plots are for p2 and p3.
cont_data1 <- data.frame(p1 = final$p1.opt,
expand.grid(p2 = seq(0.01, 0.99, 0.01), p3 = seq(0.01, 0.99, 0.01)),
N = NA, fun = NA, r.eff = NA, eff_cost = NA)
cont_data1 <- cont_data1 %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N)) %>%
arrange(fun)
cont_data1 <- cont_data1 %>% rowwise() %>% mutate(r.eff = (ff$fun / fun) , eff_cost = C * (1/r.eff))
cont_plot1 <- cont_data1 %>% ggplot(aes(x = p2, y = p3, z = r.eff)) + stat_contour(breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95,1)) +
geom_point(data = ff, aes(x = p2, y = p3, colour = "firebrick")) +
geom_dl(aes(label=..level.., colour = "firebrick"), method=list("last.bumpup",hjust = 1.1, cex = 0.8),
stat="contour",breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95)) +
geom_label_repel(data = ff, aes(x = p2, y = p3, label = "Optimal Design"), vjust = 2.4,
segment.size = 0.2) +
theme_minimal() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.line.x = element_line(colour = "black"),
axis.line.y = element_line(colour = "black"), legend.position = "none") +
ggtitle(expression(paste("Contour graph for ", p[2], " and ", p[3], " - ", p[1], " fixed to ",p[1]^"*")),
subtitle = paste("Optimal design:","p1* =", paste0(ff$p1,","),
"p2* =", paste0(ff$p2, ","), "p3* =", paste0(ff$p3))) +
labs(x = expression(p[2]), y = expression(p[3])) + coord_cartesian(xlim = c(0, 1), ylim = c(0,1)) +
scale_x_continuous(breaks = seq(0,1,0.1)) +
scale_y_continuous(breaks = seq(0,1,0.1))
#p2 fixed to its optimal value. contour plots are for p1 and p3 varying across their domain.
cont_data2 <- data.frame(p2 = final$p2.opt,
expand.grid(p1 = seq(0.01, 0.99, 0.01), p3 = seq(0.01, 0.99, 0.01)),
N = NA, fun = NA, r.eff = NA, eff_cost = NA)
cont_data2 <- cont_data2 %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N)) %>%
arrange(fun)
cont_data2 <- cont_data2 %>% rowwise() %>% mutate(r.eff = (ff$fun / fun) , eff_cost = C * (1/r.eff))
cont_plot2 <- cont_data2 %>% ggplot(aes(x = p1, y = p3, z = r.eff)) + stat_contour(breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95,1)) +
geom_point(data = ff, aes(x = p1, y = p3, colour = "firebrick")) +
geom_dl(aes(label=..level.., colour = "firebrick"), method=list("last.bumpup",hjust = 1.1, cex = 0.8),
stat="contour",breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95)) +
geom_label_repel(data = ff, aes(x = p1, y = p3, label = "Optimal Design"), vjust = 2.4,
segment.size = 0.2) +
theme_minimal() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.line.x = element_line(colour = "black"),
axis.line.y = element_line(colour = "black"), legend.position = "none") +
ggtitle(expression(paste("Contour graph for ", p[1], " and ", p[3], " - ", p[2], " fixed to ",p[2]^"*")),
subtitle = paste("Optimal design:","p1* =", paste0(ff$p1,","),
"p2* =", paste0(ff$p2, ","), "p3* =", paste0(ff$p3))) +
labs(x = expression(p[1]), y = expression(p[3])) + coord_cartesian(xlim = c(0, 1), ylim = c(0,1)) +
scale_x_continuous(breaks = seq(0,1,0.1)) +
scale_y_continuous(breaks = seq(0,1,0.1))
#p3 fixed to its optimal value. p1 and p2 are free to vary across their domain.
cont_data3 <- data.frame(p3 = final$p3.opt,
expand.grid(p1 = seq(0.01, 0.99, 0.01), p2 = seq(0.01, 0.99, 0.01)),
N = NA, fun = NA, r.eff = NA, eff_cost = NA)
cont_data3 <- cont_data3 %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N)) %>%
arrange(fun)
cont_data3 <- cont_data3 %>% rowwise() %>% mutate(r.eff = (ff$fun / fun) , eff_cost = C * (1/r.eff))
cont_plot3 <- cont_data3 %>% ggplot(aes(x = p1, y = p2, z = r.eff)) + stat_contour(breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95,1)) +
geom_point(data = ff, aes(x = p1, y = p2, colour = "firebrick")) +
geom_dl(aes(label=..level.., colour = "firebrick"), method=list("last.bumpup",hjust = 1.1, cex = 0.8),
stat="contour",breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95)) +
geom_label_repel(data = ff, aes(x = p1, y = p2, label = "Optimal Design"), vjust = 2.4,
segment.size = 0.2) +
theme_minimal() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.line.x = element_line(colour = "black"),
axis.line.y = element_line(colour = "black"), legend.position = "none") +
ggtitle(expression(paste("Contour graph for ", p[1], " and ", p[2], " - ", p[3], " fixed to ",p[3]^"*")),
subtitle = paste("Optimal design:","p1* =", paste0(ff$p1,","),
"p2* =", paste0(ff$p2, ","), "p3* =", paste0(ff$p3))) +
labs(x = expression(p[1]), y = expression(p[2])) + coord_cartesian(xlim = c(0, 1), ylim = c(0,1)) +
scale_x_continuous(breaks = seq(0,1,0.1)) +
scale_y_continuous(breaks = seq(0,1,0.1))
#Time elapsed
time_el <- Sys.time() - time_in
list(final = final, iterations = iterations, time = time_el, r.eff = r.eff, cost.eff = cost.eff,
cont_plot1 = cont_plot1, cont_plot2 = cont_plot2, cont_plot3 = cont_plot3)
}
analytic.prop()
analytic.prop(gamma1 = 0.25, gamma2 = 0.4, w13 = 0.7, w14=0.1, w23 = 0.1, w24= 0.1)
g1.vec <- g2.vec <- seq(0.00001, 0.99999, l=101)
rm(list=ls())
analytic.prop <- function(gamma1 = 0.5, gamma2 = 0.5, Cp = 50, Cn = 300, w13 = 0.25, w23 = 0.25, w14 = 0.25, w24 = 0.25, C = 100000){
time_in <- Sys.time()
g1 <- gamma1
g2 <- gamma2
#function stops if the sum of weights is different from 1
wgts <- w13 + w14 + w23 + w24
stopifnot(near(wgts, 1))
#Second-stage treatment cost
Cpn <- Cn + Cp
#Function to compute sample size, given p1, p2, p3 and the constants.
N.opt <- function(x1, x2, x3){
N <- C / (x1*(Cp+Cp*g1+(1-g1)*x2*Cn+(1-g1)*(1-x2)*Cpn) + (1-x1)*(Cn+Cn*g2+(1-g2)*x3*Cp+(1-g2)*(1-x3)*Cpn))
N <- round(N, digits = 9)
}
##Function that computes total cost
Cost <- function(N, x1, x2, x3){
C <- N*(x1*(Cp+Cp*g1+(1-g1)*x2*Cn+(1-g1)*(1-x2)*Cpn) + (1-x1)*(Cn+Cn*g2+(1-g2)*x3*Cp+(1-g2)*(1-x3)*Cpn))
}
#Function value, given p1, p2, p3, N and the constants.
fun <- function(x1, x2, x3, N){
((g1*x2+(1-g1))/(N*x1*x2) + (g2*x3+(1-g2))/(N*(1-x1)*x3))*w13 +
((g1*x2+(1-g1))/(N*x1*x2) + (g2*(1-x3)+(1-g2))/(N*(1-x1)*(1-x3)))*w14 +
((g1*(1-x2)+(1-g1))/(N*x1*(1-x2)) + (g2*x3+(1-g2))/(N*(1-x1)*x3))*w23 +
((g1*(1-x2)+(1-g1))/(N*x1*(1-x2)) + (g2*(1-x3)+(1-g2))/(N*(1-x1)*(1-x3)))*w24
}
#The temporary minimum of the function for the evaluated combinations of p1, p2 and p3 is computed
iterative <- function(p1, p2, p3){
#A dataframe with possible combinations of p1, p2 and p3 is created and the function value, the sample size
#and the cost are computed. Then the combination that provides the minimum value is chosen as the local temporary minimum.
values <- data.frame(expand.grid(p1 = p1, p2 = p2, p3 = p3), N = NA, fun = NA, Cost = NA)
values <- values %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N),Cost = Cost(N, p1, p2, p3))
intermed <- values %>% arrange(fun) %>% filter(Cost < C-0.000000001 & fun > 0 & p1>0 & p1<1 & p2<1 & p2>0 & p3<1 & p3>0) %>% slice(which.min(fun))
return(intermed)
}
#p1, p2 and p3 are initialized
p1 <- p2 <- p3 <- seq(0.01, 0.99, by = 0.02)
#First iteration is computed
iterations <- data.frame(1, iterative(p1,p2,p3))
colnames(iterations) <- c("Iteration #", "p1", "p2", "p3", "N", "fun", "Cost")
i <- 2
#The step size and the size of the interval change according to the iteration number. For iteration #2 the algorithm
#is distint than for the other iterations.
while (i < 100) {
intermed <- iterations[i-1, -1]
if(i != 2){
k <- 3.5 * 10^(-(i-1))
p1 <- seq((intermed$p1 - k), (intermed$p1 + k), by = 2 * 10^(-i))
p2 <- seq((intermed$p2 - k), (intermed$p2 + k), by = 2 * 10^(-i))
p3 <- seq((intermed$p3 - k), (intermed$p3 + k), by = 2 * 10^(-i))
} else {
k <- 1.8 * 10^(-(i-1))
p1 <- seq((intermed$p1 - k), (intermed$p1 + k), by = 0.3* 10^(-i+1))
p2 <- seq((intermed$p2 - k), (intermed$p2 + k), by = 0.3 * 10^(-i+1))
p3 <- seq((intermed$p3 - k), (intermed$p3 + k), by = 0.3 * 10^(-i+1))
}
temp <- data.frame(i, iterative(p1,p2,p3))
colnames(temp) <- c("Iteration #", "p1", "p2", "p3", "N", "fun", "Cost")
iterations <- rbind(iterations, temp)
#Convergence criteria that is met if the results found in two subsequent iterations are the same up to a certain
#degree of precision
i <- ifelse(near(iterations[i-1,2], iterations[i,2], tol = .Machine$double.eps^0.3)
& near(iterations[i-1,3], iterations[i,3], tol = .Machine$double.eps^0.3) &
near(iterations[i-1,4], iterations[i,4], tol = .Machine$double.eps^0.3) & i > 5, 100, i + 1)
}
#Optimal design is found after the convergence criterion is met
final <- iterations %>% transmute(gamma1 = g1, gamma2 = g2, Cp = Cp, Cn = Cn, Cpn = Cpn,
p1.opt = round(p1, 4), p2.opt = round(p2, 4), p3.opt = round(p3, 4),
N.opt = round(N,4), fun = round(fun, 8), Cost = round(Cost),
w13 = w13, w14 = w14, w23 = w23, w24 = w24) %>% slice(which.max(iterations$`Iteration #`))
#Relative efficiency is computed as the ratio of the function value of the balanced design and that of the optimal
#design found above. Cost efficiency is then computed
#Balanced design
N_bal <- N.opt(x1 = 0.5, x2 = 0.5, x3 = 0.5)
fun_bal <- fun(x1 = 0.5, x2 = 0.5, x3 = 0.5, N = N_bal)
#Relative efficiency and cost efficiency
r.eff <- final$fun / fun_bal
cost.eff <- final$Cost * (1/r.eff)
#Plot relative efficiency
#A dataframe with possible combinations of p1, p2 and p3 is created and relative efficiency with respect to the
#optimal design is computed
re_data <- data.frame(expand.grid(p1 = seq(0.01, 0.99, 0.03), p2 = seq(0.01, 0.99, 0.03),
p3 = seq(0.01, 0.99, 0.03)), N = NA, fun = NA, r.eff = NA, eff_cost = NA)
ff <- final %>% mutate(r.eff = 1) %>% select(p1.opt, p2.opt, p3.opt, N.opt, fun, r.eff, Cost)
colnames(ff) <- colnames(re_data)
re_data <- re_data %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N), r.eff = round((ff$fun / fun),4), eff_cost = round(C * (1/r.eff),4)) %>%
arrange(fun)
#Column names for the object containing the optimal design are set
colnames(final) <- c(paste0(intToUtf8(947),c(1:2)), "Cp", "Cn", "Cpn", "p1.opt", "p2.opt", "p3.opt", "N.opt",
paste(intToUtf8(966), "value"), "Cost", paste0(intToUtf8(955),c("13","14","23","24")))
#Contour plots
#p1 fixed to its optimal value. Contour plots are for p2 and p3.
cont_data1 <- data.frame(p1 = final$p1.opt,
expand.grid(p2 = seq(0.01, 0.99, 0.01), p3 = seq(0.01, 0.99, 0.01)),
N = NA, fun = NA, r.eff = NA, eff_cost = NA)
cont_data1 <- cont_data1 %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N)) %>%
arrange(fun)
cont_data1 <- cont_data1 %>% rowwise() %>% mutate(r.eff = (ff$fun / fun) , eff_cost = C * (1/r.eff))
cont_plot1 <- cont_data1 %>% ggplot(aes(x = p2, y = p3, z = r.eff)) + stat_contour(breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95,1)) +
geom_point(data = ff, aes(x = p2, y = p3, colour = "firebrick")) +
geom_dl(aes(label=..level.., colour = "firebrick"), method=list("last.bumpup",hjust = 1.1, cex = 0.8),
stat="contour",breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95)) +
geom_label_repel(data = ff, aes(x = p2, y = p3, label = "Optimal Design"), vjust = 2.4,
segment.size = 0.2) +
theme_minimal() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.line.x = element_line(colour = "black"),
axis.line.y = element_line(colour = "black"), legend.position = "none") +
ggtitle(expression(paste("Contour graph for ", p[2], " and ", p[3], " - ", p[1], " fixed to ",p[1]^"*")),
subtitle = paste("Optimal design:","p1* =", paste0(ff$p1,","),
"p2* =", paste0(ff$p2, ","), "p3* =", paste0(ff$p3))) +
labs(x = expression(p[2]), y = expression(p[3])) + coord_cartesian(xlim = c(0, 1), ylim = c(0,1)) +
scale_x_continuous(breaks = seq(0,1,0.1)) +
scale_y_continuous(breaks = seq(0,1,0.1))
#p2 fixed to its optimal value. contour plots are for p1 and p3 varying across their domain.
cont_data2 <- data.frame(p2 = final$p2.opt,
expand.grid(p1 = seq(0.01, 0.99, 0.01), p3 = seq(0.01, 0.99, 0.01)),
N = NA, fun = NA, r.eff = NA, eff_cost = NA)
cont_data2 <- cont_data2 %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N)) %>%
arrange(fun)
cont_data2 <- cont_data2 %>% rowwise() %>% mutate(r.eff = (ff$fun / fun) , eff_cost = C * (1/r.eff))
cont_plot2 <- cont_data2 %>% ggplot(aes(x = p1, y = p3, z = r.eff)) + stat_contour(breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95,1)) +
geom_point(data = ff, aes(x = p1, y = p3, colour = "firebrick")) +
geom_dl(aes(label=..level.., colour = "firebrick"), method=list("last.bumpup",hjust = 1.1, cex = 0.8),
stat="contour",breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95)) +
geom_label_repel(data = ff, aes(x = p1, y = p3, label = "Optimal Design"), vjust = 2.4,
segment.size = 0.2) +
theme_minimal() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.line.x = element_line(colour = "black"),
axis.line.y = element_line(colour = "black"), legend.position = "none") +
ggtitle(expression(paste("Contour graph for ", p[1], " and ", p[3], " - ", p[2], " fixed to ",p[2]^"*")),
subtitle = paste("Optimal design:","p1* =", paste0(ff$p1,","),
"p2* =", paste0(ff$p2, ","), "p3* =", paste0(ff$p3))) +
labs(x = expression(p[1]), y = expression(p[3])) + coord_cartesian(xlim = c(0, 1), ylim = c(0,1)) +
scale_x_continuous(breaks = seq(0,1,0.1)) +
scale_y_continuous(breaks = seq(0,1,0.1))
#p3 fixed to its optimal value. p1 and p2 are free to vary across their domain.
cont_data3 <- data.frame(p3 = final$p3.opt,
expand.grid(p1 = seq(0.01, 0.99, 0.01), p2 = seq(0.01, 0.99, 0.01)),
N = NA, fun = NA, r.eff = NA, eff_cost = NA)
cont_data3 <- cont_data3 %>% rowwise() %>% mutate(N = N.opt(p1, p2, p3), fun = fun(p1, p2, p3, N)) %>%
arrange(fun)
cont_data3 <- cont_data3 %>% rowwise() %>% mutate(r.eff = (ff$fun / fun) , eff_cost = C * (1/r.eff))
cont_plot3 <- cont_data3 %>% ggplot(aes(x = p1, y = p2, z = r.eff)) + stat_contour(breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95,1)) +
geom_point(data = ff, aes(x = p1, y = p2, colour = "firebrick")) +
geom_dl(aes(label=..level.., colour = "firebrick"), method=list("last.bumpup",hjust = 1.1, cex = 0.8),
stat="contour",breaks = c(0.20,0.40,
0.60,0.70,0.80,
0.90,0.95)) +
geom_label_repel(data = ff, aes(x = p1, y = p2, label = "Optimal Design"), vjust = 2.4,
segment.size = 0.2) +
theme_minimal() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.line.x = element_line(colour = "black"),
axis.line.y = element_line(colour = "black"), legend.position = "none") +
ggtitle(expression(paste("Contour graph for ", p[1], " and ", p[2], " - ", p[3], " fixed to ",p[3]^"*")),
subtitle = paste("Optimal design:","p1* =", paste0(ff$p1,","),
"p2* =", paste0(ff$p2, ","), "p3* =", paste0(ff$p3))) +
labs(x = expression(p[1]), y = expression(p[2])) + coord_cartesian(xlim = c(0, 1), ylim = c(0,1)) +
scale_x_continuous(breaks = seq(0,1,0.1)) +
scale_y_continuous(breaks = seq(0,1,0.1))
#Time elapsed
time_el <- Sys.time() - time_in
list(final = final, iterations = iterations, time = time_el, r.eff = r.eff, cost.eff = cost.eff,
cont_plot1 = cont_plot1, cont_plot2 = cont_plot2, cont_plot3 = cont_plot3)
}
analytic.prop()
analytic.prop()
